import type { ConceptMeta } from '../types';

export const CONCEPTS: ConceptMeta[] = [
  {
    id: 'caching',
    label: 'Caching',
    icon: '‚ö°',
    status: 'live',
    color: '#f59e0b',
    tagline: 'Make your app 100x faster without touching your database.',
    what: 'A cache is a fast in-memory store (think Redis) that sits between your app and the database. Instead of running the same expensive query over and over, you store the result once and serve it instantly next time.',
    realWorld:
      "Every time you open Twitter, it doesn't re-query millions of tweets. Netflix pre-loads what you're likely to watch next. Amazon's product pages are cached ‚Äî your DB would melt otherwise.",
    useCases: ['User session data', 'Product catalog pages', 'API rate limit counters', 'Leaderboards & feeds'],
    stat: '~1ms cache vs ~100ms DB',
    overview:
      'Caching stores copies of data in fast-access locations so you don\'t need to fetch it repeatedly. Instead of reading data from the database every time, you store it locally or on a nearby cache server. This dramatically reduces latency and decreases load on origin servers.',
    howItWorks:
      'When a user requests data, the system checks the cache first. If found (cache hit), it returns instantly. If not found (cache miss), it fetches from origin and stores for future requests. Popular items stay cached, while stale items get removed.',
    realWorldDetails:
      'Netflix caches popular shows at CDN edge locations so millions of user streams play without lag. When you browse, a show\'s metadata is served from the nearest cache‚Äînot Netflix\'s central servers.',
    processSteps: [
      { num: 1, desc: 'User requests resource (e.g., image.jpg)' },
      { num: 2, desc: 'Cache checks if it has the resource' },
      { num: 3, desc: 'If found: return immediately' },
      { num: 4, desc: 'If not found: fetch from origin server' },
      { num: 5, desc: 'Store in cache for future requests' },
      { num: 6, desc: 'Return to user' },
    ],
  },
  {
    id: 'load-balancer',
    label: 'Load Balancer',
    icon: '‚öñÔ∏è',
    status: 'soon',
    color: '#3b82f6',
    tagline: 'One entry point, many servers ‚Äî traffic distributed intelligently.',
    what: 'A load balancer sits in front of your server fleet and routes each incoming request to the best available server. Round-robin, least-connections, or consistent hashing ‚Äî it picks for you.',
    realWorld:
      'When millions hit YouTube simultaneously, a load balancer fans traffic across thousands of servers. No single machine gets crushed. If one dies, traffic reroutes in milliseconds.',
    useCases: ['High-traffic web apps', 'Zero-downtime deployments', 'Geographic routing', 'Health check failover'],
    stat: 'Handle millions of req/sec',
    overview: 'A load balancer distributes incoming network traffic across multiple servers.',
    howItWorks: 'Incoming requests are routed to healthy backend servers using algorithms.',
    realWorldDetails: 'YouTube uses load balancers to handle billions of requests daily.',
    processSteps: [
      { num: 1, desc: 'Request arrives at load balancer' },
      { num: 2, desc: 'Health check ensures backend is healthy' },
      { num: 3, desc: 'Request routed using algorithm (round-robin, least-conn, etc)' },
      { num: 4, desc: 'Backend server processes request' },
      { num: 5, desc: 'Response returned through load balancer' },
      { num: 6, desc: 'Connection tracked for session persistence' },
    ],
  },
  {
    id: 'message-queue',
    label: 'Message Queue',
    icon: 'üì®',
    status: 'soon',
    color: '#8b5cf6',
    tagline: 'Decouple producers from consumers. Work happens when it can.',
    what: "Instead of Service A calling Service B directly and waiting, A drops a message into a queue and moves on. B picks it up when ready. Kafka, RabbitMQ, SQS ‚Äî async by design.",
    realWorld:
      "When you post on Instagram, the notification to your followers isn't sent synchronously. It's queued. Email services, payment processors, video encoding ‚Äî all queue-based.",
    useCases: ['Email/notification delivery', 'Video transcoding jobs', 'Order processing pipelines', 'Event-driven microservices'],
    stat: 'Millions of msgs/sec (Kafka)',
    overview: 'Message queues decouple services by allowing asynchronous communication.',
    howItWorks: 'Producers send messages to a queue; consumers pick them up when ready.',
    realWorldDetails: 'Instagram queues notifications so posting doesn\'t block follower updates.',
    processSteps: [
      { num: 1, desc: 'Service A produces a message' },
      { num: 2, desc: 'Message is stored in the queue' },
      { num: 3, desc: 'Service A returns immediately' },
      { num: 4, desc: 'Service B polls the queue for messages' },
      { num: 5, desc: 'Service B processes the message' },
      { num: 6, desc: 'Message is marked as consumed' },
    ],
  },
  // {
  //   id: 'cdn',
  //   label: 'CDN',
  //   icon: 'üåê',
  //   status: 'soon',
  //   color: '#10b981',
  //   tagline: 'Your static assets, served from 200m away instead of 10,000km.',
  //   what: 'A Content Delivery Network caches your static files (JS, CSS, images, videos) at edge nodes around the globe. Users download from the nearest one instead of your origin server.',
  //   realWorld:
  //     'Cloudflare, Fastly, Akamai. When you load a website in Morocco, the CSS comes from a datacenter in Europe, not the US. Latency drops from 200ms to 20ms.',
  //   useCases: ['Static asset delivery', 'Video streaming', 'DDoS protection', 'Global SaaS products'],
  //   stat: '~20ms edge vs ~200ms origin',
  //   overview: 'A CDN is a globally distributed network of edge servers caching content.',
  //   howItWorks: 'Content is replicated across hundreds of edge locations worldwide.',
  //   realWorldDetails: 'Cloudflare serves billions of requests from edge locations daily.',
  //   processSteps: [
  //     { num: 1, desc: 'User requests static asset from origin' },
  //     { num: 2, desc: 'Request routed to nearest edge server' },
  //     { num: 3, desc: 'Edge server checks its cache' },
  //     { num: 4, desc: 'If cached: serve from edge instantly' },
  //     { num: 5, desc: 'If not: fetch from origin, cache, then serve' },
  //     { num: 6, desc: 'Response delivered with low latency' },
  //   ],
  // },
  // {
  //   id: 'event-loop',
  //   label: 'Event Loop',
  //   icon: 'üîÑ',
  //   status: 'soon',
  //   color: '#ef4444',
  //   tagline: 'How Node.js handles 10,000 connections on a single thread.',
  //   what: "JavaScript is single-threaded but non-blocking. The event loop constantly checks: is anything ready? Resolved promise? File read done? Timer fired? It handles it ‚Äî without waiting.",
  //   realWorld:
  //     "Node.js powers Uber, LinkedIn, NASA's backend. A single Node process serves thousands of concurrent users because I/O is non-blocking. No thread-per-request overhead.",
  //   useCases: ['Real-time chat apps', 'API gateways', 'Streaming data', 'WebSocket servers'],
  //   stat: '10k+ concurrent connections',
  //   overview: 'The event loop is the heart of Node.js non-blocking I/O model.',
  //   howItWorks:
  //     'The event loop polls for completed I/O operations and executes their callbacks.',
  //   realWorldDetails: 'Node.js handles millions of concurrent connections with a single thread.',
  //   processSteps: [
  //     { num: 1, desc: 'Event loop waits for I/O operations' },
  //     { num: 2, desc: 'I/O completes (file read, database query, etc)' },
  //     { num: 3, desc: 'Callback is added to callback queue' },
  //     { num: 4, desc: 'Event loop picks up callback when call stack is empty' },
  //     { num: 5, desc: 'Callback executes synchronously' },
  //     { num: 6, desc: 'Event loop continues polling' },
  //   ],
  // },
  // {
  //   id: 'microservices',
  //   label: 'Microservices',
  //   icon: 'üî∑',
  //   status: 'soon',
  //   color: '#06b6d4',
  //   tagline: 'Break the monolith. Deploy, scale, and fail independently.',
  //   what: 'Instead of one giant codebase, you build small focused services that each own a domain. User service, payment service, notification service ‚Äî each deployed and scaled separately.',
  //   realWorld:
  //     "Netflix runs 700+ microservices. Amazon's checkout is 100+ services. When the recommendation engine goes down, checkout still works. Independent blast radius.",
  //   useCases: ['Large engineering orgs', 'Independent scaling needs', 'Polyglot tech stacks', 'Continuous deployment'],
  //   stat: '700+ services at Netflix',
  //   overview: 'Microservices architecture breaks a monolith into independently deployable services.',
  //   howItWorks:
  //     'Each service owns a business domain and communicates via APIs or message queues.',
  //   realWorldDetails:
  //     'Netflix runs 700+ microservices allowing independent scaling and deployments.',
  //   processSteps: [
  //     { num: 1, desc: 'Client request hits API Gateway' },
  //     { num: 2, desc: 'Gateway routes to appropriate service' },
  //     { num: 3, desc: 'Service processes request independently' },
  //     { num: 4, desc: 'Service may call other services via API' },
  //     { num: 5, desc: 'Service returns response' },
  //     { num: 6, desc: 'Gateway aggregates and returns to client' },
  //   ],
  // },
];